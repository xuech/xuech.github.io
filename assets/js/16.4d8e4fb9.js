(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{509:function(t,s,e){t.exports=e.p+"assets/img/eventloop2.8f52e769.png"},510:function(t,s,e){t.exports=e.p+"assets/img/eventloop.3f891a7e.png"},566:function(t,s,e){"use strict";e.r(s);var a=e(6),v=Object(a.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"进程和线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#进程和线程"}},[t._v("#")]),t._v(" 进程和线程")]),t._v(" "),a("ul",[a("li",[t._v("进程：cpu"),a("strong",[t._v("资源分配")]),t._v("的最小单位")]),t._v(" "),a("li",[t._v("线程：cpu"),a("strong",[t._v("调度")]),t._v("的最小单位")])]),t._v(" "),a("blockquote",[a("p",[t._v("打开一个网页相当于新起了一个进程，一个网页中又会有多个进程，一个进程中又会有多个线程")])]),t._v(" "),a("h3",{attrs:{id:"浏览器常见进程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器常见进程"}},[t._v("#")]),t._v(" 浏览器常见进程：")]),t._v(" "),a("ul",[a("li",[a("code",[t._v("Browser")]),t._v("进程（浏览器主进程）")]),t._v(" "),a("li",[a("code",[t._v("GPU")]),t._v("进程")]),t._v(" "),a("li",[a("code",[t._v("Render")]),t._v("进程")])]),t._v(" "),a("h3",{attrs:{id:"常见的线程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的线程"}},[t._v("#")]),t._v(" 常见的线程：")]),t._v(" "),a("ul",[a("li",[t._v("GUI渲染线程\n"),a("ul",[a("li",[t._v("负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树，布局和绘制等。")]),t._v(" "),a("li",[t._v("与JS引擎线程是互斥")])])]),t._v(" "),a("li",[t._v("JS引擎线程\n"),a("ul",[a("li",[t._v("处理Javascript脚本程序(V8引擎)")])])]),t._v(" "),a("li",[t._v("事件触发线程")]),t._v(" "),a("li",[t._v("定时触发器线程")]),t._v(" "),a("li",[t._v("异步http请求线程")])]),t._v(" "),a("h2",{attrs:{id:"浏览器中的event-loop"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器中的event-loop"}},[t._v("#")]),t._v(" 浏览器中的Event Loop")]),t._v(" "),a("p",[a("code",[t._v("Javascript")]),t._v(" 有一个主线程和 "),a("code",[t._v("call-stack")]),t._v(" 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。")]),t._v(" "),a("h3",{attrs:{id:"同步任务和异步任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同步任务和异步任务"}},[t._v("#")]),t._v(" 同步任务和异步任务")]),t._v(" "),a("p",[t._v("因为js是单线程语言，所以没有并行，处理任务需要一个个执行，所以就有了同步任务和异步任务")]),t._v(" "),a("p",[a("strong",[t._v("同步任务")]),t._v("：会在调用栈中按照后进先出的顺序等待主线程依次执行\n"),a("strong",[t._v("异步任务")]),t._v("：会在异步任务有了结果后，将注册的回调函数放入任务队列中等待主线程空闲的时候（调用栈被清空），被读取到栈内等待主线程的执行")]),t._v(" "),a("h3",{attrs:{id:"event-loop-过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-过程"}},[t._v("#")]),t._v(" "),a("code",[t._v("event loop")]),t._v(" 过程")]),t._v(" "),a("p",[t._v("主线程从 “任务队列” 中读取执行事件，不断循环重复的过程，就被称为 事件循环（"),a("code",[t._v("Event Loop")]),t._v("）")]),t._v(" "),a("ul",[a("li",[t._v("同步代码依次往下，直接放在"),a("strong",[t._v("调用栈")]),t._v("中执行")]),t._v(" "),a("li",[t._v("遇到异步，先“记录”，等待时机（timer、网络请求等）")]),t._v(" "),a("li",[t._v("时机到了，就移动到"),a("strong",[t._v("任务队列")])]),t._v(" "),a("li",[t._v("如果"),a("strong",[t._v("调用栈")]),t._v("为空，即同步代码执行完成，开始下一轮 "),a("code",[t._v("Event Loop")])]),t._v(" "),a("li",[t._v("轮询查找"),a("strong",[t._v("任务队列")]),t._v("，如有则移动到"),a("strong",[t._v("调用栈")]),t._v("中执行")]),t._v(" "),a("li",[t._v("然后继续轮询查找")])]),t._v(" "),a("p",[t._v("再来一张经典的图：\n"),a("img",{attrs:{src:e(509),alt:"event loop"}})]),t._v(" "),a("h2",{attrs:{id:"宏任务和微任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务和微任务"}},[t._v("#")]),t._v(" 宏任务和微任务")]),t._v(" "),a("h3",{attrs:{id:"宏任务有哪些-微任务有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务有哪些-微任务有哪些"}},[t._v("#")]),t._v(" 宏任务有哪些？微任务有哪些？")]),t._v(" "),a("p",[t._v("宏任务：")]),t._v(" "),a("ul",[a("li",[t._v("【整体代码script】、 setTimout、setInterval、Ajax、DOM事件 【浏览器】")])]),t._v(" "),a("p",[t._v("微任务：")]),t._v(" "),a("ul",[a("li",[t._v("Promise.then()、async/await 【ES6】")])]),t._v(" "),a("blockquote",[a("p",[t._v("Promise中函数体的代码同步执行，只有promise调用then的时候，then里面的函数才会被推入微任务中")])]),t._v(" "),a("h3",{attrs:{id:"为什么微任务比宏任务执行时机要早"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么微任务比宏任务执行时机要早"}},[t._v("#")]),t._v(" 为什么微任务比宏任务执行时机要早？")]),t._v(" "),a("h3",{attrs:{id:"宏任务、微任务和dom渲染的关系及它们在-event-loop-的过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务、微任务和dom渲染的关系及它们在-event-loop-的过程"}},[t._v("#")]),t._v(" 宏任务、微任务和DOM渲染的关系及它们在 event loop 的过程")]),t._v(" "),a("p",[t._v("一次event 执行的流程：\n"),a("img",{attrs:{src:e(510),alt:"event loop"}})]),t._v(" "),a("h2",{attrs:{id:"settimeout"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#settimeout"}},[t._v("#")]),t._v(" setTimeout")]),t._v(" "),a("div",{staticClass:"language-js extra-class"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token function"}},[t._v("setTimeout")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=>")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("task")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("3000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n\n"),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("sleep")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("10000000")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n")])])]),a("p",[t._v("实际上执行task函数的时间远超3s，为什么？\n先解析下该代码的执行顺序：")]),t._v(" "),a("ul",[a("li",[t._v("代码整体执行，遇到定时器，将它的回调函数分发到宏任务队列 （Event Queue）中")]),t._v(" "),a("li",[t._v("代码继续往下执行sleep函数，执行时间超过了3s，task函数进入事件队列中")]),t._v(" "),a("li",[t._v("sleep执行完后task函数从宏任务的事件队列中进入主线程开始执行")])]),t._v(" "),a("h2",{attrs:{id:"vue-js-中-nexttick-的实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-js-中-nexttick-的实现"}},[t._v("#")]),t._v(" Vue.js 中 nextTick 的实现")]),t._v(" "),a("p",[t._v("Vue 官网上对"),a("code",[t._v("nextTick")]),t._v("的描述")]),t._v(" "),a("blockquote",[a("p",[t._v("在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。")])]),t._v(" "),a("p",[t._v("其实这是个性能优化的问题，试想如果让你在对页面上的某个节点内容进行多次赋值你会怎么处理？\n首先肯定不会每次都去操作dom更新数据，而是等到最后一次更新完成后再赋值，\n其次最好异步处理")]),t._v(" "),a("p",[t._v("当监听到数据变化后Vue将开启一个队列，如果同一个water被多次触发，只会被推入队列一次【去重】\nVue内部会将执行函数放到微任务或者宏任务中，把回调函数放入callbacks等待执行，事件循环到了执行函数依次执行callbacks中的回调")]),t._v(" "),a("h3",{attrs:{id:"这里有个知识点是我学习时一直困惑的-更新渲染是在微任务执行完之后的-那么nexttick在微任务中是怎么拿到最新的dom"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#这里有个知识点是我学习时一直困惑的-更新渲染是在微任务执行完之后的-那么nexttick在微任务中是怎么拿到最新的dom"}},[t._v("#")]),t._v(" 这里有个知识点是我学习时一直困惑的，更新渲染是在微任务执行完之后的，那么nextTick在微任务中是怎么拿到最新的DOM？")]),t._v(" "),a("p",[t._v("我的理解：")]),t._v(" "),a("p",[t._v("微任务执行完后进行的是"),a("code",[t._v("UI Render")]),t._v("，而"),a("code",[t._v("nextTick")]),t._v("在微任务中拿到的是"),a("code",[t._v("DOM Tree")])]),t._v(" "),a("p",[t._v("参考："),a("a",{attrs:{href:"https://github.com/qingzhou729/study/issues/15",target:"_blank",rel:"noopener noreferrer"}},[t._v("nextTick为什么要microtask优先?"),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=v.exports}}]);